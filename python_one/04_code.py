#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@Time : 2020-06-29 
@Author : Yong
@File : 04_code.py
@Software: PyCharm
"""


# todo：进制
"""
常见的进制 二进制，八进制，十六进制
1 bytes 1个字节 = 8位  一位只能表示 0 ，1
"""

# 二进制 0b 开头  8421    01 表示  二进制除以8 就是 字节数

a = 0b1001
#     8421

# 八进制 0o开头 用的比较少
b = 0o111
#   1*8**2+1*8**1+1

# 十六进制 0x 开头 0-F   每4位一段

c = 0x7F
# 7->0111  F->1111
# 7*16**1+15*16**0
# 127
# 上面刚好是 一个字节

# print(a)

# 十进制 采用短除法  逆序写余数 直到除不尽

# 计算机里面存的是01  变量标记的是寄存器地址  要不然不知道从哪开始

# todo : 码制

"""

原码 : 5=>0b101  -5=>-0b101
反码 : 正数原码反码相同；负数符号位不变其余安位取反
补码 : 正数原码补码相同；负数符号位不变其余取反+1

用一个字节 8位表示  无符号 0~255  有符号 -128~127

0111 1111
7    F
127

+1 原码 补码 反码相同  0000 0001


-1 原码  1000 0001 
   反码  1111 1110
   补码  1111 1111   FF
   
首位符号位 0为正数 1 为负数

可以说计算机中的数都是以补码的形式存储。
使用加法器做的减法

例如 5-1 = 5+（-1）

0000 0101
1111 1111 +
-------------
可以分解5为4+1
0000 0100
0000 0001
1111 1111 + 
-------------
先加下面的结果为1 0000 0000 因为只有一个字节 多出 部分丢弃为 0000 0000

0000 0100
0000 0000 +
--------------
0000 0100
结果为 4

例如 负数
1000 1010
1111 0110 补码在取补码就是负数的原码，原码是给人看的
 111 0110 第一位为符号位
-0x76




"""
print(bin(-5))


# todo： 算数算符

"""
真对数字，字符有别的意义
除法 a/b  自然除法  a//b 整除 向下取整
求模 a%b  余数
乘法 a*b
次方 a**3
开方 a**0.5
     
"""
# 取膜 和整数
# print(5/2)
# 2.5

# print(5//2)
# 2

tuple_a = divmod(5, 3)
print(tuple_a)
#  结果(1, 2)

# 所有的进制 都安 2进制计算

"""
# & 位与运算  全1为1
9&8

00001001
00001000 &
-----------
00001000

与运算 相等于判断 某一位有没有 的过滤运算

最后一位是 1的一定是 奇数 
例如基数： 9&l == 1   或者与9%2 == 1 


# | 或 运算  有1为1
9 | 8

00001001
00001000 |
-----------
00001001


# 位移运算 右移>> 除法；  左移<<乘法
8 >> 2 
1000 -> 10
8/2**2

8 >> 3
1000 -> 1
8/2**3

1 << 3
1->1000  
1*2**3

# 安位取反 ~  转为二进制 取反
~12
原码 0000 1100   
反码 1111 0011 最高位是1为负数，认位是负数的补码
在补 1000 1101 -0x0d 
结果为 -13


# 异或 ^ 相同为0 不同为1

00001001
00001000 ^
-----------
00000001

10 ^ 9

1010
1001 ^
--------
0101   为 

10 ^ -9

0000 1100
1111 0111 ^
------------
1111 1011 补

1000 0101 原  为-


"""
# todo： 比较运算符

"""
不同类型不能比较
等于 ==
不等 ！=
大与 >
大于等于 >=
小与 <
小于等于 <=

"""

# todo: 逻辑运算 短路运算  AND OR  提高效率  not 取反

"""
或 or  任意一个
与 and 并且  
and 前后可以使用函数  也叫短路 如果第一个成立 后面 就不用计算了  


python 中可以使用连接比较
"""

num_1 = 5
print(3 < num_1 < 10)

# todo： 赋值运算

"""
赋值运算 先算符号右边结果然后 赋值给左边 
a= min(3,5)
自加自减
-= 
+=


"""

num_2 = 0
num_2 += 1

print(num_2)

# todo : 成员运算
"""
在什么里面 或者不在 
in 

not in 
"""
# todo : 身份运算
"""
什么是什么
is

is not

"""
# todo： 优先级

"""
单目 > 双目运算符> 算术 > 比较 > 逻辑 

a + b > c and d

如果要提高优先级 加括号（）
"""